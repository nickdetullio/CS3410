int m_hailstone(int n, int A[], int s) {
        if (n < s && A[n] != 0) return A[n]; /* computed this one before */
        if (n == 1) return 0;
        else {
            int i;
            if ((n % 2) == 0) i = 1 + m_hailstone(n/2, A, s);
            else i = 1 + m_hailstone(3*n+1, A, s);
            if (n < s) A[n] = i; /* save this answer for reuse later */
            return i;
        }
    }

START: ADDIU $t0, $0, 0			#set temp register $t0 to 0 for conditionals
       ADDIU $t1, $0, 1			#set temp register $t1 to 1 for conditionals
       ADDIU $t2, $a0, 0		#set temp register $t2 to argument n
       LW $t3, $t2($a1)			#set temp register $t3 to A[n] 
       ADDIU $t4, $a2, 0		#set temp register $t4 to s
       SUB $t5, $t2, $t4		#store result of n - s in temp register $t5

BNE $t3, $0, COND			#branch to COND if A[n] != 0
SLL $0, $0, 0 				#delay slot for BNE

BEQ $t2, $t1, EXIT2			#branch to EXIT2 if n == 1
SLL $0, $0, 0				#delay slot for BEQ

ANDI $t6, $t2, 1			#ANDI of n and 1 for modulo arithmetic stored in $t6
BEQ $t6, $t0, EXIT3			#branch to EXIT3 if (n % 2) == 0

ADDU $a0, $t1, $t1			#argument n set to 3n + 1
ADDU $a0, $a0, $t1
ADDIU $a0, $a0, 1
J START					#jump to start for recursive call
SLL $0, $0, 0				#delay slot for J
ADDIU $t7, $v0, 1			#value i = i + m_hailstone(3*n+1, A, s)
ADDU $v0, $t7, $0			#return value $v0 set to i

J COND2					#jump to COND2
SLL $0, $0, 0				#delay slot for J

EXIT: ADDIU $v0, $t3, 0			#set return value $v0 to A[n]
      JR $31				#JR 31 to return A[n] in $v0

EXIT2: ADDIU $v0, $0, 0			#set return value $v0 to 0
       JR $31				#JR 31 to return 0 in $v0

EXIT3: SRA $a0, $t2, 1			#argument n set to n/2
       ADDIU $t7, $t7, 1		#value i set to 1 
       J START				#jump to start for recursive call
       SLL $0, $0, 0			#delay slot for J
       ADDIU $t7, $v0, 1		#i = i + m_hailstone(n/2, A, s)
       ADDU $v0, $t7, $0		#return value $v0 set to i
       
       J COND2				#jump to COND2
       SLL $0, $0, 0			#delay slot for J

EXIT4: SW $t7, $t2($a1)			#store i in A[n] (A[n] = i)
       JR $31				#JR 31 to return i

COND: BLTZ $t5, EXIT			#branch to exit if n < s ($t5 < 0)
      SLL $0, $0, 0			#delay slot for bltz

COND2: BLTZ $t5, EXIT4			#branch to EXIT4 if n < s ($t5 < 0)
       SLL $0, $0, 0			#delay slot for BLTZs
       JR $31				#JR 31 to return i
