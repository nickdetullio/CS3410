int r_hailstone(int n) {
        if (n == 1) return 0;
        else if ((n % 2) == 0) return 1 + r_hailstone(n/2);
        else return 1 + r_hailstone(3*n+1);
    }

ADDIU $v0, $0, 0			#set return value $v0 to 0

START: ADDIU $t0, $0, 1			#set temp register $t0 to 1 for conditionals
       ADDIU $t1, $a0, 0		#set temp register $t1 to argument n
       BEQ $t1, $t0, EXIT		#branch to EXIT if n == 1
       SLL $0, $0, 0			#delay slot for BEQ

ANDI $t2, $t1, 1			#ANDI of n and 1 for modulo arithmetic stored in $t2
BEQ $t1, $t0, EXIT2			#branch to EXIT2 if (n % 2) == 0
SLL $0, $0, 0				#delay slot for BEQ

ADDU $a0, $t1, $t1			#argument n set to 3n + 1
ADDU $a0, $a0, $t1
ADDU $a0, $a0, 1
J START					#jump to START for recursive call
SLL $0, $0, 0				#delay slot for J
ADDIU $v0, $v0, 1			#return value set to 1 + r_hailstone(2*n+1)
J EXIT					#jump to EXIT
SLL $0, $0, 0				#delay slot for J

EXIT: JR $31				#JR 31 to return $v0

EXIT2: SRA $a0, $t1, 1			#argument n set to n/2
J START					#jump to start for recursive call
SLL $0, $0, 0				#delay slot for J
ADDIU $v0, $v0, 1			#return value $v0 set to 1 + r_hailstone(n/2)
J EXIT					#jump to EXIT
SLL $0, $0, 0				#delay slot for J


